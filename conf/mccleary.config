params {
  config_profile_description = 'Yale YCRC Configurations'
  config_profile_contact = 'Ryan A. Hagenson'
}

profiles {
  mccleary {
    executor {
      submitRateLimit = '200/1h'
    }

    singularity {
      enabled = true
    }

    params {
      igenomes_base = '/gpfs/gibbs/data/genomes/'
      max_memory = 1.TB
      max_cpus = 64
      max_time = 24.hours
    }

    process {
      executor = 'slurm'
      cache = 'lenient'
      scratch = true
      
      // Update amount of max retries and set "retry" as the error strategy for all error codes
      errorStrategy = 'retry'
      maxRetries = 5
      maxErrors = '-1'

      // Split on task time to place on the correct queue
      queue = {
        switch (task.time) {
          case { it > 1.day }:
            return 'week'
          default:
            return 'day'
        }
      }

      // Ensure the max time requested is 7 days (anything over automatically fails)
      time = { task.time < 7.days ? task.time : 7.days}

      // 4GB/CPU and 1+ hour of run time to *hopefully* use scavenge
      withLabel:process_low {
        cpus = { check_max( 2 * task.attempt, 'cpus' ) }
        memory = { check_max( 8.GB * task.attempt, 'memory' ) }
        time = { check_max( 1.hour * task.attempt, 'time' ) }
        queue = {
          switch (task.attempt) {
            case { it <= 3 }:
              return 'day,scavenge'
            default:
              return 'day'
          }
        }
      }

      // 4GB/CPU and 6+ hour of run time *attempt* to use scavenge
      withLabel:process_medium {
        cpus = { check_max( 8 * task.attempt, 'cpus' ) }
        memory = { check_max( 32.GB * task.attempt, 'memory' ) }
        time = { check_max( 6.hours * task.attempt, 'time' ) }
        queue = {
          switch (task.attempt) {
            case { it <= 1 }:
              return 'day,scavenge'
            default:
              return 'day'
          }
        }
      }

      // Do not bother checking max_time, set above 24.h
      withLabel:process_high {
        cpus = { check_max( 12 * task.attempt, 'cpus' ) }
        memory = { check_max( 120.GB * task.attempt, 'memory' ) }
        time = { 24.hours * task.attempt < 7.days ? 24.hours * task.attempt : 7.days}
        queue = 'week'
      }
    }
  }
}

// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}
